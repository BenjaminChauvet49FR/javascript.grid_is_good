-Colorations et X dans les cases :
	-Possède un X toute case sans propriété autre que celle d'être complémentaire à une case à "propriété", hormis dans une optique de dualité d'un remplissage d'un ensemble de case donnée (exemple : les cases doivent être fermées ou ouvertes et il y a X cases fermées dans la région) doivent avoir un X.
	Une case fermée est dite à propriété active si sa présence peut forcer la présence d'autres cases ouvertes indépendemment des contraintes de remplissage de région.
	Par exemple, dans Heyawake, Koburin, Yajilin : deux cases "fermées" (selon la définition de case fermée propre à chaque puzzle) ne peuvent être adjacentes. Dans Country Road, si une case est fermée le long d'une frontière de région, celle de l'autre côté de la frontière doit être ouverte.  
	Ce dernier exemple de Country Road pourrait être contourné en considérant que "au moins une des deux cases de part et d'autre de la frontière doit être ouverte" mais cette convention est refusée. Car cela donne un certain pouvoir aux cases fermées.
	- Une case avec une propriété active est colorée.
	- Une case "bannie" qui ne comporte aucune indication mais qui ne compte pas comme une case d'un autre type à propriétés a un X. (exemple : cases sans indices non colorées de Yajilin, cases sans indices n'appartenant pas à un domino de Shimaguni)

-Nommage d'un solveur :
 ...
 
Grille VS tableau VS ensemble :
	-Grille : entité logique pouvant avoir des propriétés. Contient notamment un tableau dont les cases ou les propriétés de cases sont modifiées via des "get" et "set". Peut être appelé "ensemble".
	-Tableau : ensemble à deux dimensions sans forcément plus de logique (même si les données contenues dans le tableau peuvent correspondre à de la logique dans la résolution d'un puzzle)
	-Ensemble : grille avec davantage de propriétés qu'un tableau. Peut s'appeler grille ou ensemble selon appréciation.
	
-Cases WALLGRID.OUT_OF_REGIONS et leur oppositions à WALLGRID.CLOSED : 
	-Uniquement dans les puzzles à région : ce sont les cases sans régions.
	-WALLGRID.CLOSED désigne l'état d'une case fermée (indépendemment de ses murs ET indépendemment de l'établissement de régions) ou peut désigner l'état d'un mur fermé. 
	-WALLGRID.OUT_OF_REGIONS n'intervient que dans un tableau de cases à régions en tant que "index de région non représentée". Puisque les index des régions démarrent à 0, cette valeur vaut typiquement -1.
	-La distinction entre WALLGRID.OUT_OF_REGIONS et WALLGRID.CLOSED est renforcée par la méthode de transformation de WallGrid en tableau à région (ou grille à région à l'avenir ?)
	
-Déductions :
	Toute méthode dont les appels sont sous la forme (p_eventList = p_solver.XXX(p_eventList, ...) ) devrait avoir un nom commençant par "deductions" pour refléter le fait qu'on établit une liste d'évènements en déductions. J'ai commencé à le mettre en place avec Norinori.
	La méthode déductions peut tester si les déductions sont nécessaires ou avoir des prérequis (exemple : "la case p_x, p_y doit être ouverte"), auquel cas il vaut mieux les ajouter en commentaires
	On peut terminer le nom de la méthode par "deductions" à la place. (ce que je fais d'ailleurs pour Putteria)
	
-p_eventList contre p_listEvents contre p_listEventsToApply :
	-Essayer d'adopter "p_futureEventsList" pour la fonction principale de déductions et "p_eventsList" pour les fonctions dérivées
	-Pour les solveurs : "p_eventChoiceList" et "p_eventChoice" 
		-Ne pas confondre avec "ChoiceEvent" dans les puzzles à choix de valeurs
	
-Ordre des arguments dans les évènements :
	-Tout ce qui trait aux positions doit être au début des arguments de l'évènement, suivi des directions, enfin les états/symboles/valeurs... 
	Cela peut se justifier par les passes, où on fait varier l'état.
	
-'Coordinates' vs 'Spaces' :
	-Dans la mesure du possible, tout objet ne contenant que des propriétés x et y correspondant à des coordonnées de cases doit s'appeler "coordinates" (ou son diminutif coors). On tolèrera "spaces" pour les listes de cases d'un solveur.

-Revirements (ou volte-face, comme on dit dans les Ace Attorney) :
	-Les évènements peuvent tout à fait être partagés entre plusieurs solveurs.
	
-Ordre de priorité du taf :
	-Quand j'ai une méthode "révolutionnaire" ou "pratique", je ne dois pas forcément chercher à l'ajouter sur chaque puzzle existant si ce n'est pas urgent 
	-Exemples : Urgent : nouveau système de sauvegarde, de chargement de fichier... Pas urgent : méthode du solveur pour factoriser le code dans le setup.

-Fusion et découpage des commits :
	-Un commit dont les seules traces n'impactent pas le fonctionnement du code (pose d'espaces, renommage de fonctions, suppression de commentaires ou fonctions qui ne sont plus appelées ET ne serviront manifestement plus, modification du puzzle par défaut dans le HTML...) peut être fondu dans un commit plus grand. 
	-Si les fichiers modifiés n'appartiennent pas au même puzzle qu'un puzzle qui a eu des traces plus importantes, il faudra cependant l'écrire.
	
-Chargement grille éditeur et utilisation éditeur :
	-Par simplification, on utilise TOUJOURS le wallArray même quand il est invisible, sinon ça complique trop la donne au niveau des rotations. Pour autant on cherche à minimiser le copier-coller dans InputEditor.
	
-Sur les passes :
	-On ne va pas utiliser une closure à la fois pour la passe d'une région/case/... et pour la multipasse car l'appel à la fonction est le plus pratique pour passer un ensemble de case, d'autant que cet ensemble peut revêtir différentes natures (cf. Star battle)
		-Utilisation de "catégories de passes" dans plusieurs puzzles tels que ceux à cloisons (Usotatami, Galaxies). Mais aussi Akari ! On peut passer des cases individuellement.
	-Génération des évènements d'une passe : on pourrait fabriquer une liste d'évènements pour la passe à partir d'une liste de coordonnées mais l'intérêt serait moindre et ça renforcerait le côté "usine à gaz".
	-Si on crée une fonction qui crée une simple liste d'évènements (pour une simple case ou une cloison) et une fonction qui crée une liste de listes (pour un ensemble de cases / cloisons) : faire apparaître "listEvents" dans la 1ère et "allEvents" dans la 2nde pour bien les distinguer. Fait dans AkariSolver.
	
x, y en argument de fonction comprise dans une autre fonction ! (exemple : drawer de Starbattle)

-Features uniques d'un puzzle : 
	-Star battle, sélection des cases à passer : que c'est une feature unique, je généraliserai dès qu'il y aura un autre puzzle qui l'utilisera. Pour l'instant je l'ai spécialisé à ce solveur. Eh oui c'est un choix !

Tableaux constants utilisés par plusieurs solveurs car transverses :
-En 'Label' (commence par majuscule et CamlCase) : LabelFenceState, LabelDirections
-Autres : KnownDirections

SPACE_CHOICE : utilisé UNIQUEMENT pour les valeurs des cases ou de leurs propriétés, pas les évènements où un YES ou un NO fait l'affaire ! (Du moins dans Shugaku)

-Solveur Yagit, obtenir une propriété d'une case :
OK pour dire getFenceRight au lieu de getFenceRightState malgré la présence de deux arguments tant qu'il n'y a pas d'ambiguité !

------

-Sauvegarde des sudokus :
Sauvegarde classique, pas de préfixe spécial. Juste on indique que c'est un carré avec un '9' qui indique la taille du carré (peut être un 12 ou un 16 mais d'autres suffixes seront à solliciter.)

-Editeur et changement de puzzles :
Tout se joue dans la combobox de l'input (ainsi qu'au setup) ! On a un seul 'editorcore', ça suffit largement à nos besoins (je veux dire pas besoin de créer 3 ou 4 pages HTML)

-Sudoku "classique" (à cases numériques) et non-classique et grilles imbriquées.
Côté éditeur, distinction entre sudokus "numériques" classiques (déduire à partir de nombres) et autres sudokus dans le système de sauvegarde. 
Enfin, jusq'au jour où on a plusieurs grilles de Sudoku Kropki/Killer imbriquées...
Dans le doute, les solveurs Kropki/Killer utiliseront des grilles multiples.

-Input solver : clickCanvasAction / clickCanvasAction

------

(fait pour Putteria : deductions et renommage des listes d'events + hautes conventions)	
